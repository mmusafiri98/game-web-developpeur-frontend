<!DOCTYPE html>
<html>

<head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <title>tetris</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-image: url('tetris.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            margin: 0;
            padding: 0;
            height: 100vh;
            height: 59%;
            /* Le body prend toute la hauteur de la fenêtre */
            margin: 0;
            /* Supprimer les marges */
            display: flex;
            justify-content: center;
            /* Centrer horizontalement */
            align-items: center;
            /* Centrer verticalement */
            /* Couleur du body en bleu */
            overflow: hidden;
        }

        #keyboard {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 2px;
        }

        #row {
            display: flex;
            justify-content: center;
            margin: 5px;
        }

        #pause {
            animation: blink 0.7s steps(2, pause) infinite;
            background: rgb(201, 195, 195);
            border-radius: 2px;
            color: rgb(155, 76, 76);
            cursor: pointer;
            font-size: 22px
        }

        button {
            padding: 9px 10px;
            font-size: 2px;
            margin: 5px;
            cursor: pointer;
            border: 2px solid #007bff;
            background-color: #fff;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #007bff;
            color: white;
        }

        #tetris {
            width: 360px;
            border: 1px solid blue;
            padding: 20px;
        }

        #canvas {
            width: 220px;
            height: 440px;
            background-color: black;
            /* Couleur du canvas en rose */
            color: pink;
            position: relative;
        }

        #canvas h1 {
            margin: 0;
            padding: 0;
            text-align: center;
            font-size: 30px;
            padding-top: 200px;
        }

        .piece {
            border: 1px solid white;
            position: absolute;
        }

        #start {
            animation: blink 0.7s steps(2, start) infinite;
            background: yellow;
            border-radius: 2px;
            color: rgb(126, 126, 145);
            cursor: pointer;
            font-size: 28px;
        }

        @keyframes blink {
            to {
                outline: #e1ff5f solid 1px;
            }
        }

        .red {
            color: #f00000;
        }

        .square {
            position: absolute;
            width: 19px;
            height: 19px;
            border: 1px solid white;
        }

        .type0 {
            background-color: #a000f0;
        }

        .type1 {
            background-color: #00f0f0;
        }

        .type2 {
            background-color: #f0a000;
        }

        .type3 {
            background-color: #0000f0;
        }

        .type4 {
            background-color: #00f000;
        }

        .type5 {
            background-color: #f00000;
        }

        .type6 {
            background-color: #f0f000;
        }

        #next_shape {
            position: relative;
            background-color: #000;
            border: 1px solid white;
            width: 110px;
            height: 115px;
        }

        #info {
            background-color: blue;
            color: #fff;
            float: right;
            width: 110px;
            height: 720px;
            padding: 10px;
        }

        #Pause {
            animation: blink 0.7s steps(2, pause) infinite;
            background: violet;
            border-radius: 2px;
            color: white;
            cursor: pointer;
            font-size: 28px;
        }

        p {
            font-size: 18px;
        }

        #left {
            animation: blink 0.7s steps(2, pause) infinite;
            background: rgb(201, 195, 195);
            border-radius: 2px;
            color: rgb(155, 76, 76);
            cursor: pointer;
            font-size: 29px
        }

        #right {
            animation: blink 0.7s steps(2, pause) infinite;
            background: rgb(201, 195, 195);
            border-radius: 2px;
            color: rgb(155, 76, 76);
            cursor: pointer;
            font-size: 29px
        }

        #rotate {
            animation: blink 0.7s steps(2, pause) infinite;
            background: rgb(201, 195, 195);
            border-radius: 2px;
            color: rgb(155, 76, 76);
            cursor: pointer;
            font-size: 22px
        }

        #top {
            animation: blink 0.7s steps(2, pause) infinite;
            background: rgb(201, 195, 195);
            border-radius: 2px;
            color: rgb(155, 76, 76);
            cursor: pointer;
            font-size: 22px
        }

        h1 {
            font-family: 'Arial', sans-serif;
            font-size: 5em;
            /* Taille du texte */
            letter-spacing: 5px;
            /* Espacement entre les lettres */
            animation: colorAnimation 2s infinite alternate;
            text-shadow: 0px 0px 10px rgba(255, 255, 255, 0.5);
            /* Ombre pour un effet brillant */
        }

        /* Animation de couleurs */
        @keyframes colorAnimation {
            0% {
                color: #FF6347;
                /* Rouge */
            }

            16% {
                color: #FFD700;
                /* Jaune */
            }

            32% {
                color: #1E90FF;
                /* Bleu */
            }

            48% {
                color: #32CD32;
                /* Vert */
            }

            64% {
                color: #EE82EE;
                /* Violet */
            }

            80% {
                color: #FF8C00;
                /* Orange */
            }

            100% {
                color: #00CED1;
                /* Cyan */
            }
        }

        .container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 354px;

            background-color: blue;
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>tetris</h1>
        <div id="tetris">
            <div id="info">
                <div id="next_shape"></div>
                <p id="level">Level: <span></span></p>
                <p id="lines">Lines: <span></span></p>
                <p id="score">Score: <span></span></p>
                <p id="time">Time: <span></span></p>
                <button id="start">Start</button>
                <div id="keyboard">
                    <div class="row">
                        <button data-key="37" id="left"><span class="material-icons">arrow_left</span></button>
                        <button data-key="39" id="right"><span class="material-icons">arrow_right</span></button>
                    </div>
                    <div class="row">
                        <button data-key="38" id="rotate"><span class="material-icons">arrow_upward</span></button>
                        <button data-key="40" id="down"><span class="material-icons">arrow_downward</span></button>
                    </div>
                    <div class="row">
                        <button data-key="27" id="Pause"><span class="material-icons">pause</span></button>
                    </div>
                    <p class="white">Press the button ESC(Pause)<span></span></p>
                </div>
            </div>
            <div id="canvas"></div>
        </div>
        <script>
            //fonction qui va contenir le debout du jeux et l objet tetris avec c est propriete
            (function () {
                var isStart = false;
                var tetris = {
                    board: [],
                    boardDiv: null,
                    canvas: null,
                    pSize: 20,
                    canvasHeight: 440,
                    canvasWidth: 200,
                    boardHeight: 0,
                    boardWidth: 0,
                    spawnX: 4,
                    spawnY: 1,
                    shapes: [
                        [
                            [-1, 1],
                            [0, 1],
                            [1, 1],
                            [0, 0], //TEE
                        ],
                        [
                            [-1, 0],
                            [0, 0],
                            [1, 0],
                            [2, 0], //line
                        ],
                        [
                            [-1, -1],
                            [-1, 0],
                            [0, 0],
                            [1, 0], //L EL
                        ],
                        [
                            [1, -1],
                            [-1, 0],
                            [0, 0],
                            [1, 0], //R EL
                        ],
                        [
                            [0, -1],
                            [1, -1],
                            [-1, 0],
                            [0, 0], // R ess
                        ],
                        [
                            [-1, -1],
                            [0, -1],
                            [0, 0],
                            [1, 0], //L ess
                        ],
                        [
                            [0, -1],
                            [1, -1],
                            [0, 0],
                            [1, 0], //square
                        ],
                    ],
                    tempShapes: null,
                    curShape: null,
                    curShapeIndex: null,
                    curX: 0,
                    curY: 0,
                    curSqs: [],
                    nextShape: null,
                    nextShapeDisplay: null,
                    nextShapeIndex: null,
                    sqs: [],
                    score: 0,
                    scoreDisplay: null,
                    level: 1,
                    levelDisplay: null,
                    numLevels: 10,
                    time: 0,
                    maxTime: 1000,
                    timeDisplay: null,
                    isActive: 0,
                    curComplete: false,
                    timer: null,
                    sTimer: null,
                    speed: 700,
                    lines: 0,
                    isPause: false,
                    init: function () {
                        isStart = true;
                        this.canvas = document.getElementById("canvas");
                        this.initBoard();
                        this.initInfo();
                        this.initLevelScores();
                        this.initShapes();
                        this.bindKeyEvents();
                        this.play();
                    },
                    initBoard: function () {
                        this.boardHeight = this.canvasHeight / this.pSize;
                        this.boardWidth = this.canvasWidth / this.pSize;
                        var s = this.boardHeight * this.boardWidth;
                        for (var i = 0; i < s; i++) {
                            this.board.push(0);
                        }
                        //this.boardDiv = document.getElementById('board); //for debugging
                    },
                    initInfo: function () {
                        this.nextShapeDisplay = document.getElementById("next_shape");
                        this.levelDisplay = document
                            .getElementById("level")
                            .getElementsByTagName("span")[0];
                        this.timeDisplay = document
                            .getElementById("time")
                            .getElementsByTagName("span")[0];
                        this.scoreDisplay = document
                            .getElementById("score")
                            .getElementsByTagName("span")[0];
                        this.linesDisplay = document
                            .getElementById("lines")
                            .getElementsByTagName("span")[0];
                        this.setInfo("time");
                        this.setInfo("score");
                        this.setInfo("level");
                        this.setInfo("lines");
                    },
                    initShapes: function () {
                        this.curSqs = [];
                        this.curComplete = false;
                        this.shiftTempShapes();
                        this.curShapeIndex = this.tempShapes[0];
                        this.curShape = this.shapes[this.curShapeIndex];
                        this.initNextShape();
                        this.setCurCoords(this.spawnX, this.spawnY);
                        this.drawShape(this.curX, this.curY, this.curShape);
                    },
                    initNextShape: function () {
                        if (typeof this.tempShapes[1] === "undefined") {
                            this.initTempShapes();
                        }
                        try {
                            this.nextShapeIndex = this.tempShapes[1];
                            this.nextShape = this.shapes[this.nextShapeIndex];
                            this.drawNextShape();
                        } catch (e) {
                            throw new Error("Could not create next shape. " + e);
                        }
                    },
                    initTempShapes: function () {
                        this.tempShapes = [];
                        for (var i = 0; i < this.shapes.length; i++) {
                            this.tempShapes.push(i);
                        }
                        var k = this.tempShapes.length;
                        while (--k) {
                            //Fisher Yates Shuffle
                            var j = Math.floor(Math.random() * (k + 1));
                            var tempk = this.tempShapes[k];
                            var tempj = this.tempShapes[j];
                            this.tempShapes[k] = tempj;
                            this.tempShapes[j] = tempk;
                        }
                    },
                    shiftTempShapes: function () {
                        try {
                            if (
                                typeof this.tempShapes === "undefined" ||
                                this.tempShapes === null
                            ) {
                                this.initTempShapes();
                            } else {
                                this.tempShapes.shift();
                            }
                        } catch (e) {
                            throw new Error("Could not shift or init tempShapes: " + e);
                        }
                    },
                    initTimer: function () {
                        var me = this;
                        var tLoop = function () {
                            me.incTime();
                            me.timer = setTimeout(tLoop, 2000);
                        };
                        this.timer = setTimeout(tLoop, 2000);
                    },
                    initLevelScores: function () {
                        var c = 1;
                        for (var i = 1; i <= this.numLevels; i++) {
                            this["level" + i] = [c * 1000, 40 * i, 5 * i]; //for nxt level, row score, p sore,
                            c = c + c;
                        }
                    },
                    setInfo: function (el) {
                        this[el + "Display"].innerHTML = this[el];
                    },
                    drawNextShape: function () {
                        var ns = [];
                        for (var i = 0; i < this.nextShape.length; i++) {
                            ns[i] = this.createSquare(
                                this.nextShape[i][0] + 2,
                                this.nextShape[i][1] + 2,
                                this.nextShapeIndex
                            );
                        }
                        this.nextShapeDisplay.innerHTML = "";
                        for (var k = 0; k < ns.length; k++) {
                            this.nextShapeDisplay.appendChild(ns[k]);
                        }
                    },
                    drawShape: function (x, y, p) {
                        for (var i = 0; i < p.length; i++) {
                            var newX = p[i][0] + x;
                            var newY = p[i][1] + y;
                            this.curSqs[i] = this.createSquare(newX, newY, this.curShapeIndex);
                        }
                        for (var k = 0; k < this.curSqs.length; k++) {
                            this.canvas.appendChild(this.curSqs[k]);
                        }
                    },
                    createSquare: function (x, y, type) {
                        var el = document.createElement("div");
                        el.className = "square type" + type;
                        el.style.left = x * this.pSize + "px";
                        el.style.top = y * this.pSize + "px";
                        return el;
                    },
                    removeCur: function () {
                        var me = this;
                        this.curSqs.eachdo(function () {
                            me.canvas.removeChild(this);
                        });
                        this.curSqs = [];
                    },
                    setCurCoords: function (x, y) {
                        this.curX = x;
                        this.curY = y;
                    },
                    bindKeyEvents: function () {
                        console.log("evenement de touche de clavier ");
                        var me = this;

                        // Fonction de gestion pour le clavier et les boutons HTML
                        var cb = function (keyCode) {
                            me.handleKey({ keyCode: keyCode });  // Simule un événement clavier avec le code de touche correspondant
                        };
                        // Gestion des événements de clavier
                        var event = "keydown";  // Utiliser "keydown" pour les événements clavier par défaut
                        var keyboardHandler = function (e) {
                            me.handleKey(e);
                        };
                        //verifie si la fentre a ajoute l evenement pour le clique 
                        if (window.addEventListener) {
                            document.addEventListener(event, keyboardHandler, false);
                        } else {
                            //sinon il ya pas de evenement 
                            document.attachEvent("on" + event, keyboardHandler);
                        }

                        // Gestion des clics sur les boutons HTML
                        var buttons = document.querySelectorAll("#keyboard button");  // Sélectionne tous les boutons du div #keyboard
                        buttons.forEach(function (button) {
                            button.addEventListener("click", function () {
                                var keyCode = parseInt(button.getAttribute("data-key"), 10);  // Récupère le code de la touche à partir de l'attribut data-key
                                cb(keyCode);  // Appelle la fonction de gestion avec le code de touche récupéré
                            });
                        });
                    },
                    handleKey: function (e) {
                        console.log("mouvement de touche pour le jeux ");
                        var key = this.whichKey(e); // Récupère le code de la touche

                        // Flèche gauche
                        if (key === 37) {
                            this.move("L"); // Déplacer à gauche
                        }
                        // Flèche haut
                        else if (key === 38) {
                            this.move("RT"); // Rotation de la pièce
                        }
                        // Flèche droite
                        else if (key === 39) { // Correction : le code pour la flèche droite est 39, pas 175
                            this.move("R"); // Déplacer à droite
                        }
                        // Flèche bas
                        else if (key === 40) {
                            this.move("D"); // Accélérer la descente
                        }
                        // Échap
                        else if (key === 27) {
                            this.togglePause(); // Mettre en pause le jeu
                        }
                    }
                    ,

                    // Récupère le code de la touche en fonction de l'événement
                    whichKey: function (e) {
                        console.log("mouvemente de detection de touche de clavier ");
                        var keyCode;
                        // Détecte le code de la touche sur le navigateur 
                        if (window.event) {
                            //aggiunge l evento 
                            keyCode = window.event.keyCode;
                        } else if (e) {
                            keyCode = e.keyCode; // Modern browsers
                        }
                        return keyCode;
                    },
                    //fonction incremente le time 
                    incTime: function () {
                        //questo per l incrementazione del tempo
                        this.time++;
                        //questo serve ad accedere all informazione sul tempo
                        this.setInfo("time");
                    },
                    //fonction pour incremente le score 
                    incScore: function (amount) {
                        // // Incrementa il punteggio attuale con l'ammontare fornito come parametro
                        this.score = this.score + amount;
                        // Aggiorna l'interfaccia grafica per mostrare il punteggio aggiornato
                        this.setInfo("score");
                    },
                    //fonction pour incrementare il livello del gioco 
                    incLevel: function () {
                        // se questo livello e incrementato 
                        if (this.level++) {

                            //questa velocita sara -85
                            this.speed = this.speed - 85;
                            //e si accedere a livello all informazione presente nel level 
                            this.setInfo("level");
                        }
                    },
                    //funzione per incrementare la linea 
                    incLines: function (num) {
                        this.lines += num;
                        this.setInfo("lines");
                    },
                    //fonction pour calculer le score de joeur 
                    calcScore: function (args) {
                        var lines = args.lines || 0;
                        var shape = args.shape || false;
                        var speed = args.speed || 0;
                        var score = 0;
                        if (lines > 0) {
                            score += lines * this["level" + this.level][1];
                            this.incLines(lines);
                        }
                        if (shape === true) {
                            score += shape * this["level" + this.level][2];
                        }
                        /*if (speed > 0){ score += speed * this["level" +this .level[3]];}*/
                        this.incScore(score);
                    },
                    //fonction pour checkscore 
                    checkScore: function () {
                        if (this.score >= this["level" + this.level][0]) {
                            this.incLevel();
                        }
                    },
                    //fonction pour affiche game over quand le jouer perd 
                    gameOver: function () {
                        this.clearTimers();
                        isStart = false;
                        this.canvas.innerHTML = "<h1>GAME OVER</h1>";
                    },
                    //fonction pout joue au jeux 
                    play: function () {
                        console.log("intialisazione del gioco");
                        var me = this;
                        if (this.timer === null) {
                            this.initTimer();
                        }
                        var gameLoop = function () {
                            me.move("D");
                            if (me.curComplete) {
                                me.markBoardShape(me.curX, me.curY, me.curShape);
                                me.curSqs.eachdo(function () {
                                    me.sqs.push(this);
                                });
                                me.calcScore({ shape: true });
                                me.checkRows();
                                me.checkScore();
                                me.initShapes();
                                me.play();
                            } else {
                                me.pTimer = setTimeout(gameLoop, me.speed);
                            }
                        };
                        this.pTimer = setTimeout(gameLoop, me.speed);
                        this.isActive = 1;
                    },
                    //fonction pour mettre en pause le jeux si la conditio du jeux 
                    togglePause: function () {
                        console.log("Bouton pause cliqué");
                        // Bascule l'état de pause (true ou false) 
                        //est mes pause si la condition de pause est a vrai 
                        this.isPause = !this.isPause;
                        //si ca c est en pause                     
                        if (this.isPause) {
                            //pour arrete le jeux  on utilise
                            this.clearTimers();
                            //indique maintenant que le jeux est en pause                    
                            this.isActive = 0;
                            //Si non on continue a joue 
                        } else {
                            this.play();
                        }
                    },
                    //fonction qui arrete le jeux 
                    clearTimers: function () {
                        //fonction pour arrete le principale temps 
                        clearTimeout(this.timer);
                        //fonction pour arrete le deuxieme temps 
                        clearTimeout(this.pTimer);
                        //variable qui indique le temps principale et deuxieme sont arrete 
                        this.timer = null;
                        this.pTimer = null;
                    },
                    //fonction pour bouge le piece
                    move: function (dir) {
                        console.log("deplacement de bloc de tetris pour le jeux ");
                        var s = "";
                        var me = this;
                        var tempX = this.curX;
                        var tempY = this.curY;
                        switch (dir) {
                            case "L":
                                s = "left";
                                tempX -= 1;
                                break;
                            case "R":
                                s = "right";
                                tempX += 1;
                                break;
                            case "D":
                                s = "top";
                                tempY += 1;
                                break;
                            case "RT":
                                this.rotate();
                                return true;
                                break;
                            default:
                                throw new Error("wtf");
                                break;
                        }
                        if (this.checkMove(tempX, tempY, this.curShape)) {
                            this.curSqs.eachdo(function (i) {
                                var l = parseInt(this.style[s], 10);
                                dir === "L" ? (l -= me.pSize) : (l += me.pSize);
                                this.style[s] = l + "px";
                            });
                            this.curX = tempX;
                            this.curY = tempY;
                        } else if (dir === "D") {
                            if (this.curY === 1 || this.time === this.maxTime) {
                                this.gameOver();
                                return false;
                            }
                            this.curComplete = true;
                        }
                    },

                    rotate: function () {
                        console.log("rotation de bloc de tetris");
                        if (this.curShapeIndex !== 6) {
                            //square
                            var temp = [];
                            this.curShape.eachdo(function () {
                                temp.push([this[1] * -1, this[0]]);
                            });
                            if (this.checkMove(this.curX, this.curY, temp)) {
                                this.curShape = temp;
                                this.removeCur();
                                this.drawShape(this.curX, this.curY, this.curShape);
                            } else {
                                throw new Error("Could not rotate!");
                            }
                        }
                    },
                    checkMove: function (x, y, p) {
                        if (this.isOB(x, y, p) || this.isCollision(x, y, p)) {
                            return false;
                        }
                        return true;
                    },
                    isCollision: function (x, y, p) {
                        var me = this;
                        var bool = false;
                        p.eachdo(function () {
                            var newX = this[0] + x;
                            var newY = this[1] + y;
                            if (me.boardPos(newX, newY) === 1) {
                                bool = true;
                            }
                        });
                        return bool;
                    },
                    isOB: function (x, y, p) {
                        var w = this.boardWidth - 1;
                        var h = this.boardHeight - 1;
                        var bool = false;
                        p.eachdo(function () {
                            var newX = this[0] + x;
                            var newY = this[1] + y;
                            if (newX < 0 || newX > w || newY < 0 || newY > h) {
                                bool = true;
                            }
                        });
                        return bool;
                    },
                    getRowState: function (y) {
                        var c = 0;
                        for (var x = 0; x < this.boardWidth; x++) {
                            if (this.boardPos(x, y) === 1) {
                                c = c + 1;
                            }
                        }
                        if (c === 0) {
                            return "E";
                        }
                        if (c === this.boardWidth) {
                            return "F";
                        }
                        return "U";
                    },
                    checkRows: function () {
                        var me = this;
                        var start = this.boardHeight;
                        this.curShape.eachdo(function () {
                            var n = this[1] + me.curY;
                            console.log(n);
                            if (n < start) {
                                start = n;
                            }
                        });
                        console.log(start);
                        var c = 0;
                        var stopCheck = false;
                        for (var y = this.boardHeight - 1; y >= 0; y--) {
                            switch (this.getRowState(y)) {
                                case "F":
                                    this.removeRow(y);
                                    c++;
                                    break;
                                case "E":
                                    if (c === 0) {
                                        stopCheck = true;
                                    }
                                    break;
                                case "U":
                                    if (c > 0) {
                                        this.shiftRow(y, c);
                                    }
                                    break;
                                default:
                                    break;
                            }
                            if (stopCheck === true) {
                                break;
                            }
                        }
                        if (c > 0) {
                            this.calcScore({ lines: c });
                        }
                    },
                    shiftRow: function (y, amount) {
                        var me = this;
                        for (var x = 0; x < this.boardWidth; x++) {
                            this.sqs.eachdo(function () {
                                if (me.isAt(x, y, this)) {
                                    me.setBlock(x, y + amount, this);
                                }
                            });
                        }
                        me.emptyBoardRow(y);
                    },
                    emptyBoardRow: function (y) {
                        for (var x = 0; x < this.boardWidth; x++) {
                            this.markBoardAt(x, y, 0);
                        }
                    },
                    removeRow: function (y) {
                        for (var x = 0; x < this.boardWidth; x++) {
                            this.removeBlock(x, y);
                        }
                    },
                    removeBlock: function (x, y) {
                        var me = this;
                        this.markBoardAt(x, y, 0);
                        this.sqs.eachdo(function (i) {
                            if (me.getPos(this)[0] === x && me.getPos(this)[1] === y) {
                                me.canvas.removeChild(this);
                                me.sqs.splice(i, 1);
                            }
                        });
                    },
                    setBlock: function (x, y, block) {
                        this.markBoardAt(x, y, 1);
                        var newX = x * this.pSize;
                        var newY = y * this.pSize;
                        block.style.left = newX + "px";
                        block.style.top = newY + "px";
                    },
                    isAt: function (x, y, block) {
                        if (this.getPos(block)[0] === x && this.getPos(block)[1] === y) {
                            return true;
                        }
                        return false;
                    },
                    getPos: function (block) {
                        var p = [];
                        p.push(parseInt(block.style.left, 10) / this.pSize);
                        p.push(parseInt(block.style.top, 10) / this.pSize);
                        return p;
                    },
                    getBoardIdx: function (x, y) {
                        return x + y * this.boardWidth;
                    },
                    boardPos: function (x, y) {
                        return this.board[x + y * this.boardWidth];
                    },
                    markBoardAt: function (x, y, val) {
                        this.board[this.getBoardIdx(x, y)] = val;
                    },
                    markBoardShape: function (x, y, p) {
                        var me = this;
                        p.eachdo(function (i) {
                            var newX = p[i][0] + x;
                            var newY = p[i][1] + y;
                            me.markBoardAt(newX, newY, 1);
                        });
                    },
                    isIE: function () {
                        return this.bTest(/IE/);
                    },
                    isFirefox: function () {
                        return this.bTest(/Firefox/);
                    },
                    isSafari: function () {
                        return this.bTest(/Safari/);
                    },
                    bTest: function (rgx) {
                        return rgx.test(navigator.userAgent);
                    },
                };
                const btn = document.querySelector("#start");
                btn.addEventListener("click", function () {
                    btn.style.display = "none";
                    if (!isStart) {
                        tetris.init();
                    }
                });
            })();
            // Ajout des contrôles pour les boutons pour le mouvement de block
            const keyLeft = document.querySelector("#left");
            const keyright = document.querySelector("#right");
            const keyRotate = document.querySelector("#rotate");
            const keydown = document.querySelector("#down");
            const keyPause = document.querySelector("#Pause");
            // Ajouter les événements de click aux boutons
            keyLeft.addEventListener("click", function () {
                tetris.handleKey({ e: 37 }); // Simule la touche flèche gauche
            });
            keyright.addEventListener("click", function () {
                tetris.handleKey({ e: 39 }); // Simule la touche flèche droite
            });
            keyRotate.addEventListener("click", function () {
                tetris.handleKey({ e: 38 }); // Simule la touche flèche haut (rotation)
            });
            keydown.addEventListener("click", function () {
                tetris.handleKey({ e: 40 }); // Simule la touche flèche bas
            });
            keyPause.addEventListener("click", function () {
                tetris.togglePause(); // Simule la touche ESC (pause)
            });
            if (!Array.prototype.eachdo) {
                Array.prototype.eachdo = function (fn) {
                    for (var i = 0; i < this.length; i++) {
                        fn.call(this[i], i);
                    }
                };
            }
            if (!Array.prototype.remDup) {
                Array.prototype.remDup = function () {
                    var temp = [];
                    for (var i = 0; i < this.length; i++) {
                        var bool = true;
                        for (var j = i + 1; j < this.length; j++) {
                            if (this[i] === this[j]) {
                                bool = false;
                            }
                        }
                        if (bool === true) {
                            temp.push(this[i]);
                        }
                    }
                    return temp;
                };
            }
        </script>
</body>

</html>
